---
id: 2474
title: Spring, JDO and transactions on Google App Engine
date: 2010-08-03T10:00:07+00:00
author: Peter Backx
layout: post
guid: http://www.streamhead.com/?p=2474
permalink: /spring-jdo-transactions-appengine/
dsq_thread_id:
  - "125395692"
categories:
  - Java and JavaScript
---
Although I haven&#8217;t mentioned it in a while, I&#8217;m still continuing development on my Vaadin project. As with all new technology, sometimes some frustration is involved. Here&#8217;s an overview of how I&#8217;m currently using Spring&#8217;s transaction management and its JDO support. The setup seems easy enough, until you try to run it on the actual AppEngine. Turns out there are some details you need to take care of.

<!--more-->I use an approach similar to the one 

<a title="Spring + JDO in Google App Engine" href="http://objectuser.wordpress.com/2009/06/30/spring-jdo-in-google-app-engine/" target="_blank">Objectuser describes in his post</a>. It really is a piece of cake, you just set up a `LocalPersistenceManagerFactoryBean` to point to the &#8220;transactions-optional&#8221; factory that the App Engine supplies:

<pre lang="xml">&lt;bean id="persistenceManagerFactory">
  &lt;property name="persistenceManagerFactoryName" value="transactions-optional" />
&lt;/bean></pre>

After that you can use everything that Spring supplies. For instance, I went for an annotations based transactions management instead of defining my own pointcuts as in the post mentioned above. <a title="Spring JDO" href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/orm.html#orm-jdo" target="_blank">The documentation on the Spring site</a> gives a pretty good, although condensed, explanation of everything you need to know.

Locally, everything works just fine, but when I deployed the application, I ran into a few issues. Most importantly, using the `TransactionAwarePersistenceManagerFactoryProxy` resulted in a `java.lang.NoClassDefFoundError: javax/naming/NamingException`. Apparently, somewhere in the bowls of that code a catch block uses this exception. There are a few posts around the web that suggests rolling your own version of some of the Spring libraries. That&#8217;s something I really really want to avoid, I&#8217;d rather just get rid of Spring if that were the only solution.

There was a different solution though: Doing my own transaction management. Always closing persistence managers after loading and persisting entities. I centralized all my datastore operations, so that was fairly easy, but it still is too bad I can&#8217;t take the easy way out and let Spring handle it for me.

It is however another library I can remove from the dependencies, so once I get to optimizing the application that&#8217;s already a small win.

Another gotcha was when I first used an index (apart from the primary keys). The local server does not complain when you haven&#8217;t explicitly defined your indexes, it simply generates one on the fly. The real App Engine runtime however requires that you define the index before using it. It is possible to use an autogenerated file, but this one sometimes gets cleaned up, so you might suddenly loose your indices.

This is all <a title="Java Datastore Index Configuration" href="http://code.google.com/appengine/docs/java/config/indexconfig.html" target="_blank">well documented in the App Engine reference guide</a>, so really, there&#8217;s no one to blame but me. Still, I have a feeling many developers will run into this issue, so I thought I&#8217;d mention it.

<!-- AddThis Advanced Settings generic via filter on the_content -->

<!-- AddThis Share Buttons generic via filter on the_content -->